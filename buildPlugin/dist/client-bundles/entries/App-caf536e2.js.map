{"version":3,"file":"App-caf536e2.js","sources":["../../../src/client/ctx.tsx","../../../node_modules/jotai/esm/vanilla.mjs","../../../node_modules/jotai/esm/index.mjs","../../../node_modules/jotai/esm/utils.mjs","../../../src/client/state.ts","../../../src/client/utils.ts","../../../src/client/useAppState.tsx","../../../src/client/PageLoader.tsx","../../../src/client/App.tsx"],"sourcesContent":["import { createContext } from 'react'\nimport type { PagesLoaded } from '../../clientTypes'\n\n/**\n * During ssr hydration, we pass all the data needed by App\n * with this ctx\n * so the App can render the page data directly\n * instead of render the loading state\n */\nexport const dataCacheCtx = createContext<PagesLoaded>({})\nexport const setDataCacheCtx = createContext<\n  React.Dispatch<React.SetStateAction<PagesLoaded>>\n>(() => {\n  throw new Error(`setDataCacheCtx not found`)\n})\n","let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === \"function\" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = \"fulfilled\";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = \"rejected\";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => \"v\" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] atom state not found\");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env && import.meta.env.MODE) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(\n            (v) => {\n              if (!settled) {\n                resolvePromise(promise, v);\n                resolve(v);\n              }\n            },\n            (e) => {\n              if (!settled) {\n                rejectPromise(promise, e);\n                reject(e);\n              }\n            }\n          ).finally(() => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = (next) => {\n            if (!settled) {\n              settled = true;\n              next.then(\n                (v) => resolvePromise(promise, v),\n                (e) => rejectPromise(promise, e)\n              );\n              resolve(next);\n            }\n          };\n        });\n        promise.status = \"pending\";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.warn(\"[Bug] no atom state to flush\");\n        }\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n","import { createContext, useState, useEffect, useRef, createElement, useContext, useReducer, useDebugValue, useCallback } from 'react';\nimport { atom as atom$1 } from 'jotai/vanilla';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        // not invalidated\n        d: /* @__PURE__ */ new Map()\n      };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\n            \"Found initial value for derived atom which can cause unexpected behavior\",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && \"p\" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !(\"v\" in atomState) || // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        // copy everything\n        y: false\n        // invalidated\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && // not invalidated\n        \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !(\"p\" in aState) && // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && \"p\" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\n            \"Reading pending atom state in write operation. We throw a promise for now.\",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\n          \"[Bug] no value found while reading atom in write operation. This is probably a bug.\",\n          a\n        );\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && // invalidated\n        (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction atom(read, write) {\n  return atom$1(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !atomState.y) {\n      throw new Error(\"should not be invalidated\");\n    }\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = useReducer(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  useEffect(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback(\n    (update) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\n      \"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\"\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, registerPromiseAbort as SECRET_INTERNAL_registerPromiseAbort, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n","import { RESET, unstable_NO_STORAGE_VALUE } from 'jotai/vanilla/utils';\nexport { RESET, unstable_NO_STORAGE_VALUE } from 'jotai/vanilla/utils';\nimport * as Jotai from 'jotai';\nimport { atom, SECRET_INTERNAL_getScopeContext, useAtom, useSetAtom, SECRET_INTERNAL_registerPromiseAbort } from 'jotai';\nimport { useContext, useCallback, useMemo } from 'react';\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(initialValue, (get, set, update) => {\n    const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n    set(anAtom, nextValue === RESET ? initialValue : nextValue);\n  });\n  return anAtom;\n}\n\nconst WRITE_ATOM = \"w\";\nconst RESTORE_ATOMS = \"h\";\n\nfunction useResetAtom(anAtom, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const store = useContext(ScopeContext).s;\n  const setAtom = useCallback(\n    () => store[WRITE_ATOM](anAtom, RESET),\n    [store, anAtom]\n  );\n  return setAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, scope) {\n  const [state, setState] = useAtom(anAtom, scope);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, action) => set(anAtom, reducer(get(anAtom), action))\n  );\n  return anAtom;\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove)\n      return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getWeakCacheItem = (cache, deps) => {\n  do {\n    const [dep, ...rest] = deps;\n    const entry = cache.get(dep);\n    if (!entry) {\n      return;\n    }\n    if (!rest.length) {\n      return entry[1];\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst setWeakCacheItem = (cache, deps, item) => {\n  do {\n    const [dep, ...rest] = deps;\n    let entry = cache.get(dep);\n    if (!entry) {\n      entry = [ new WeakMap()];\n      cache.set(dep, entry);\n    }\n    if (!rest.length) {\n      entry[1] = item;\n      return;\n    }\n    cache = entry[0];\n    deps = rest;\n  } while (deps.length);\n};\nconst createMemoizeAtom = () => {\n  const cache = /* @__PURE__ */ new WeakMap();\n  const memoizeAtom = (createAtom, deps) => {\n    const cachedAtom = getWeakCacheItem(cache, deps);\n    if (cachedAtom) {\n      return cachedAtom;\n    }\n    const createdAtom = createAtom();\n    setWeakCacheItem(cache, deps, createdAtom);\n    return createdAtom;\n  };\n  return memoizeAtom;\n};\n\nconst memoizeAtom$4 = createMemoizeAtom();\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memoizeAtom$4(() => {\n    const refAtom = atom(() => ({}));\n    const derivedAtom = atom((get) => {\n      const slice = selector(get(anAtom));\n      const ref = get(refAtom);\n      if (\"prev\" in ref && equalityFn(ref.prev, slice)) {\n        return ref.prev;\n      }\n      ref.prev = slice;\n      return slice;\n    });\n    return derivedAtom;\n  }, [anAtom, selector, equalityFn]);\n}\n\nfunction useAtomCallback(callback, scope) {\n  const anAtom = useMemo(\n    () => atom(\n      null,\n      (get, set, [arg, resolve, reject]) => {\n        try {\n          resolve(callback(get, set, arg));\n        } catch (e) {\n          reject(e);\n        }\n      }\n    ),\n    [callback]\n  );\n  const invoke = useSetAtom(anAtom, scope);\n  return useCallback(\n    (arg) => {\n      let isSync = true;\n      let settled = {};\n      const promise = new Promise((resolve, reject) => {\n        invoke([\n          arg,\n          (v) => {\n            if (isSync) {\n              settled = { v };\n            } else {\n              resolve(v);\n            }\n          },\n          (e) => {\n            if (isSync) {\n              settled = { e };\n            } else {\n              reject(e);\n            }\n          }\n        ]);\n      });\n      isSync = false;\n      if (\"e\" in settled) {\n        throw settled.e;\n      }\n      if (\"v\" in settled) {\n        return settled.v;\n      }\n      return promise;\n    },\n    [invoke]\n  );\n}\n\nconst memoizeAtom$3 = createMemoizeAtom();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null)\n    return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  return memoizeAtom$3(() => {\n    const frozenAtom = atom(\n      (get) => deepFreeze(get(anAtom)),\n      (_get, set, arg) => set(anAtom, arg)\n    );\n    return frozenAtom;\n  }, [anAtom]);\n}\nfunction freezeAtomCreator(createAtom) {\n  return (...params) => {\n    const anAtom = createAtom(...params);\n    const origRead = anAtom.read;\n    anAtom.read = (get) => deepFreeze(origRead(get));\n    return anAtom;\n  };\n}\n\nconst memoizeAtom$2 = createMemoizeAtom();\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memoizeAtom$2(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read2 = (get) => {\n            const ref = get(refAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write2 = (get, set, update) => {\n            const ref = get(refAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, ref.prev);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            set(arrAtom, [\n              ...arr2.slice(0, index2),\n              nextItem,\n              ...arr2.slice(index2 + 1)\n            ]);\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read2, write2) : atom(read2);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const refAtom = atom(() => ({}));\n      const read = (get) => {\n        const ref = get(refAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, ref.prev);\n        ref.prev = arr;\n        return mapping.atomList;\n      };\n      const write = (get, set, action) => {\n        if (\"read\" in action) {\n          console.warn(\"atomToRemove is deprecated. use action with type\");\n          action = { type: \"remove\", atom: action };\n        }\n        switch (action.type) {\n          case \"remove\": {\n            const index = get(splittedAtom).indexOf(action.atom);\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                ...arr.slice(index + 1)\n              ]);\n            }\n            break;\n          }\n          case \"insert\": {\n            const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index >= 0) {\n              const arr = get(arrAtom);\n              set(arrAtom, [\n                ...arr.slice(0, index),\n                action.value,\n                ...arr.slice(index)\n              ]);\n            }\n            break;\n          }\n          case \"move\": {\n            const index1 = get(splittedAtom).indexOf(action.atom);\n            const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n            if (index1 >= 0 && index2 >= 0) {\n              const arr = get(arrAtom);\n              if (index1 < index2) {\n                set(arrAtom, [\n                  ...arr.slice(0, index1),\n                  ...arr.slice(index1 + 1, index2),\n                  arr[index1],\n                  ...arr.slice(index2)\n                ]);\n              } else {\n                set(arrAtom, [\n                  ...arr.slice(0, index2),\n                  arr[index1],\n                  ...arr.slice(index2, index1),\n                  ...arr.slice(index1 + 1)\n                ]);\n              }\n            }\n            break;\n          }\n        }\n      };\n      const splittedAtom = isWritable(arrAtom) ? atom(read, write) : atom(read);\n      return splittedAtom;\n    },\n    keyExtractor ? [arrAtom, keyExtractor] : [arrAtom]\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  const anAtom = atom(\n    (get) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        return set(overwrittenAtom, EMPTY);\n      }\n      return set(\n        overwrittenAtom,\n        typeof update === \"function\" ? update(get(anAtom)) : update\n      );\n    }\n  );\n  return anAtom;\n}\n\nconst memoizeAtom$1 = createMemoizeAtom();\nconst emptyArrayAtom = atom(() => []);\nfunction waitForAll(atoms) {\n  const createAtom = () => {\n    const unwrappedAtoms = unwrapAtoms(atoms);\n    const derivedAtom = atom((get) => {\n      const promises = [];\n      const values = unwrappedAtoms.map((anAtom, index) => {\n        try {\n          return get(anAtom);\n        } catch (e) {\n          if (e instanceof Promise) {\n            promises[index] = e;\n          } else {\n            throw e;\n          }\n        }\n      });\n      if (promises.length) {\n        throw Promise.all(promises);\n      }\n      return wrapResults(atoms, values);\n    });\n    return derivedAtom;\n  };\n  if (Array.isArray(atoms)) {\n    if (atoms.length) {\n      return memoizeAtom$1(createAtom, atoms);\n    }\n    return emptyArrayAtom;\n  }\n  return createAtom();\n}\nconst unwrapAtoms = (atoms) => Array.isArray(atoms) ? atoms : Object.getOwnPropertyNames(atoms).map((key) => atoms[key]);\nconst wrapResults = (atoms, results) => Array.isArray(atoms) ? results : Object.getOwnPropertyNames(atoms).reduce(\n  (out, key, idx) => ({ ...out, [key]: results[idx] }),\n  {}\n);\n\nfunction createJSONStorage(getStringStorage) {\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key) => {\n      var _a, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2);\n          } catch {\n            return unstable_NO_STORAGE_VALUE;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a = getStringStorage()) == null ? void 0 : _a.getItem(key)) != null ? _b : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.setItem(key, JSON.stringify(newValue));\n    },\n    removeItem: (key) => {\n      var _a;\n      return (_a = getStringStorage()) == null ? void 0 : _a.removeItem(key);\n    }\n  };\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n    storage.subscribe = (key, callback) => {\n      const storageEventCallback = (e) => {\n        if (e.key === key && e.newValue) {\n          callback(JSON.parse(e.newValue));\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage(\n  () => typeof window !== \"undefined\" ? window.localStorage : void 0\n);\nfunction atomWithStorage(key, initialValue, storage = defaultStorage) {\n  const getInitialValue = () => {\n    const value = storage.getItem(key);\n    if (value instanceof Promise) {\n      return value.then((v) => v === unstable_NO_STORAGE_VALUE ? initialValue : v);\n    }\n    return value === unstable_NO_STORAGE_VALUE ? initialValue : value;\n  };\n  const baseAtom = atom(storage.delayInit ? initialValue : getInitialValue());\n  baseAtom.onMount = (setAtom) => {\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom);\n      setAtom(getInitialValue());\n    }\n    if (storage.delayInit) {\n      const value = getInitialValue();\n      if (value instanceof Promise) {\n        value.then(setAtom);\n      } else {\n        setAtom(value);\n      }\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\nfunction atomWithHash(key, initialValue, options) {\n  const serialize = (options == null ? void 0 : options.serialize) || JSON.stringify;\n  const deserialize = (options == null ? void 0 : options.deserialize) || ((str) => {\n    try {\n      return JSON.parse(str || \"\");\n    } catch {\n      return unstable_NO_STORAGE_VALUE;\n    }\n  });\n  const subscribe = (options == null ? void 0 : options.subscribe) || ((callback) => {\n    window.addEventListener(\"hashchange\", callback);\n    return () => {\n      window.removeEventListener(\"hashchange\", callback);\n    };\n  });\n  const hashStorage = {\n    getItem: (key2) => {\n      if (typeof location === \"undefined\") {\n        return unstable_NO_STORAGE_VALUE;\n      }\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      const storedValue = searchParams.get(key2);\n      return deserialize(storedValue);\n    },\n    setItem: (key2, newValue) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.set(key2, serialize(newValue));\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(\n          null,\n          \"\",\n          location.pathname + location.search + \"#\" + searchParams.toString()\n        );\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    removeItem: (key2) => {\n      const searchParams = new URLSearchParams(location.hash.slice(1));\n      searchParams.delete(key2);\n      if (options == null ? void 0 : options.replaceState) {\n        history.replaceState(\n          null,\n          \"\",\n          location.pathname + location.search + \"#\" + searchParams.toString()\n        );\n      } else {\n        location.hash = searchParams.toString();\n      }\n    },\n    ...(options == null ? void 0 : options.delayInit) && { delayInit: true },\n    subscribe: (key2, setValue) => {\n      const callback = () => {\n        const searchParams = new URLSearchParams(location.hash.slice(1));\n        const str = searchParams.get(key2);\n        if (str !== null) {\n          setValue(deserialize(str));\n        } else {\n          setValue(initialValue);\n        }\n      };\n      return subscribe(callback);\n    }\n  };\n  return atomWithStorage(key, initialValue, hashStorage);\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (\"e\" in result) {\n        throw result.e;\n      }\n      return result.d;\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, scope) {\n  const ScopeContext = SECRET_INTERNAL_getScopeContext(scope);\n  const scopeContainer = useContext(ScopeContext);\n  const store = scopeContainer.s;\n  const hydratedSet = getHydratedSet(scopeContainer);\n  const tuplesToRestore = [];\n  for (const tuple of values) {\n    const atom = tuple[0];\n    if (!hydratedSet.has(atom)) {\n      hydratedSet.add(atom);\n      tuplesToRestore.push(tuple);\n    }\n  }\n  if (tuplesToRestore.length) {\n    store[RESTORE_ATOMS](tuplesToRestore);\n  }\n}\nfunction getHydratedSet(scopeContainer) {\n  let hydratedSet = hydratedMap.get(scopeContainer);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(scopeContainer, hydratedSet);\n  }\n  return hydratedSet;\n}\n\nconst memoizeAtom = createMemoizeAtom();\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memoizeAtom(() => {\n    const loadableAtomCache = /* @__PURE__ */ new WeakMap();\n    const catchAtom = atom((get) => {\n      let promise;\n      try {\n        const data = get(anAtom);\n        const loadableAtom2 = atom({ state: \"hasData\", data });\n        return loadableAtom2;\n      } catch (error) {\n        if (error instanceof Promise) {\n          promise = error;\n        } else {\n          const loadableAtom2 = atom({\n            state: \"hasError\",\n            error\n          });\n          return loadableAtom2;\n        }\n      }\n      const cached = loadableAtomCache.get(promise);\n      if (cached) {\n        return cached;\n      }\n      const loadableAtom = atom(\n        LOADING,\n        async (get2, set) => {\n          try {\n            const data = await get2(anAtom, { unstable_promise: true });\n            set(loadableAtom, { state: \"hasData\", data });\n          } catch (error) {\n            set(loadableAtom, { state: \"hasError\", error });\n          }\n        }\n      );\n      loadableAtom.onMount = (init) => {\n        init();\n      };\n      loadableAtomCache.set(promise, loadableAtom);\n      return loadableAtom;\n    });\n    const derivedAtom = atom((get) => {\n      const loadableAtom = get(catchAtom);\n      return get(loadableAtom);\n    });\n    return derivedAtom;\n  }, [anAtom]);\n}\n\nfunction abortableAtom(read, write) {\n  return atom((get) => {\n    const controller = new AbortController();\n    const promise = read(get, { signal: controller.signal });\n    if (promise instanceof Promise) {\n      SECRET_INTERNAL_registerPromiseAbort(promise, () => controller.abort());\n    }\n    return promise;\n  }, write);\n}\n\nconst useAtomValue = (...args) => {\n  console.warn(\"[DEPRECATED]: use `useAtomValue` from `jotai` instead.\");\n  return Jotai.useAtomValue(...args);\n};\nconst useUpdateAtom = (...args) => {\n  console.warn(\"[DEPRECATED]: use `useSetAtom` from `jotai` instead.\");\n  return Jotai.useSetAtom(...args);\n};\n\nexport { abortableAtom, atomFamily, atomWithDefault, atomWithHash, atomWithObservable, atomWithReducer, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, useAtomCallback, useAtomValue, useHydrateAtoms, useReducerAtom, useResetAtom, useUpdateAtom, waitForAll };\n","import { useMemo, useEffect, useState } from 'react'\nimport { dequal } from 'dequal'\nimport type { SetAtom } from 'jotai/core/atom'\nimport { atom, useAtom } from 'jotai'\nimport { atomFamily, useAtomValue, useUpdateAtom } from 'jotai/utils'\nimport type {\n  PageLoaded,\n  UseStaticData,\n  Theme,\n  UseAllPagesOutlines,\n} from '../../clientTypes'\n\nexport let useTheme: () => Theme\nexport let usePagePaths: () => string[]\nexport let usePageModule: (path: string) => Promise<PageModule> | undefined\nexport let useStaticData: UseStaticData\nexport let useAllPagesOutlines: UseAllPagesOutlines\n\ninterface PageModule {\n  ['default']: PageLoaded\n}\n\nimport initialPages from '/@react-pages/pages'\nimport initialTheme from '/@react-pages/theme'\n\n// TODO: simplify this\n// there is no easy way to handle the hmr of module such as `/@react-pages/pages/page1` so stop trying it\n// https://github.com/vitejs/vite-plugin-react-pages/pull/19#discussion_r604251258\n\nconst initialPagePaths = Object.keys(initialPages)\n\n// This HMR code assumes that our Jotai atoms are always managed\n// by the same Provider. It also mutates during render, which is\n// generally discouraged, but in this case it's okay.\nif (import.meta.hot) {\n  let setTheme: SetAtom<{ Theme: Theme }, void> | undefined\n  import.meta.hot!.accept('/@react-pages/theme', (module) => {\n    // console.log('@@hot update /@react-pages/theme', module)\n    if (!module) {\n      console.error('unexpected hot module', module)\n      return\n    }\n    setTheme?.({ Theme: module.default })\n  })\n\n  const themeAtom = atom({ Theme: initialTheme })\n  useTheme = () => {\n    const [{ Theme }, set] = useAtom(themeAtom)\n    setTheme = set\n    return Theme\n  }\n\n  let setPages: SetAtom<any, void> | undefined\n  import.meta.hot!.accept('/@react-pages/pages', (module) => {\n    // console.log('@@hot update /@react-pages/pages', module)\n    if (!module) {\n      console.error('unexpected hot module', module)\n      return\n    }\n    setPages?.(module.default)\n  })\n\n  let setAllPagesOutlines: SetAtom<any, void> | undefined\n  import.meta.hot!.accept('/@react-pages/allPagesOutlines', (module) => {\n    // console.log('@@hot update /@react-pages/allPagesOutlines', module)\n    if (!module) {\n      console.error('unexpected hot module', module)\n      return\n    }\n    setAllPagesOutlines?.(module)\n  })\n\n  const pagesAtom = atom(initialPages)\n  const pagePathsAtom = atom(initialPagePaths.sort())\n  const staticDataAtom = atom(toStaticData(initialPages))\n  const allPagesOutlinesAtom = atom(initialPages)\n\n  const setPagesAtom = atom(null, (get, set, newPages: any) => {\n    let newStaticData: Record<string, any> | undefined\n\n    const pages = get(pagesAtom)\n    for (const path in newPages) {\n      const newPage = newPages[path]\n      const page = pages[path]\n\n      // Avoid changing the identity of `page.staticData` unless\n      // a change is detected. This prevents unnecessary renders\n      // of components that depend on `useStaticData(path)` call.\n      if (page && dequal(page.staticData, newPage.staticData)) {\n        newPage.staticData = page.staticData\n      } else {\n        newStaticData ??= {}\n        newStaticData[path] = newPage.staticData\n      }\n    }\n\n    // detect deleted pages\n    for (const path in pages) {\n      if (!newPages[path]) {\n        newStaticData ??= {}\n        newStaticData[path] = undefined\n      }\n    }\n\n    // Update the `pagesAtom` every time, since no hook uses it directly.\n    set(pagesAtom, newPages)\n\n    // Avoid re-rendering `useStaticData()` callers if no data changed.\n    if (newStaticData) {\n      newStaticData = {\n        ...get(staticDataAtom),\n        ...newStaticData,\n      }\n      // filter out deleted paths\n      newStaticData = Object.fromEntries(\n        Object.entries(newStaticData).filter(([k, v]) => v !== undefined)\n      )\n      set(staticDataAtom, newStaticData)\n    }\n\n    // Avoid re-rendering `usePagePaths()` callers if no paths were added/deleted.\n    const newPagePaths = Object.keys(newPages).sort()\n    if (!dequal(get(pagePathsAtom), newPagePaths)) {\n      set(pagePathsAtom, newPagePaths)\n    }\n  })\n\n  const dataAtoms = atomFamily((path: string) =>\n    atom((get) => {\n      const pages = get(pagesAtom)\n      return pages[path]\n    })\n  )\n\n  const staticDataAtoms = atomFamily((path: string) =>\n    atom((get) => {\n      const pages = get(pagesAtom)\n      const page = pages[path]\n      return page?.staticData\n    })\n  )\n\n  usePagePaths = () => {\n    setPages = useUpdateAtom(setPagesAtom)\n    return useAtomValue(pagePathsAtom)\n  }\n\n  usePageModule = (pagePath) => {\n    const data = useAtomValue(dataAtoms(pagePath))\n    return useMemo(() => data?.data(), [data])\n  }\n\n  useStaticData = (pagePath?: string, selector?: Function) => {\n    const staticData = pagePath ? staticDataAtoms(pagePath) : staticDataAtom\n    if (selector) {\n      const selection = useMemo(\n        () => atom((get) => selector(get(staticData))),\n        [staticData]\n      )\n      return useAtomValue(selection)\n    }\n    return useAtomValue(staticData)\n  }\n\n  useAllPagesOutlines = (timeout: number) => {\n    const [data, set] = useAtom(allPagesOutlinesAtom)\n    setAllPagesOutlines = set\n    useEffect(() => {\n      setTimeout(() => {\n        import('/@react-pages/allPagesOutlines').then((mod) => {\n          set(mod)\n        })\n      }, timeout)\n    }, [])\n    return data\n  }\n}\n\n// Static mode\nelse {\n  useTheme = () => initialTheme\n  usePagePaths = () => initialPagePaths\n  usePageModule = (path) => {\n    const page = initialPages[path]\n    return useMemo(() => page?.data(), [page])\n  }\n  useStaticData = (path?: string, selector?: Function) => {\n    if (path) {\n      const page = initialPages[path]\n      const staticData = page?.staticData || {}\n      return selector ? selector(staticData) : staticData\n    }\n    return toStaticData(initialPages)\n  }\n  useAllPagesOutlines = (timeout: number) => {\n    const [data, set] = useState<any>()\n    useEffect(() => {\n      setTimeout(() => {\n        import('/@react-pages/allPagesOutlines').then((mod) => {\n          set(mod)\n        })\n      }, timeout)\n    }, [])\n    return data\n  }\n}\n\nfunction toStaticData(pages: Record<string, any>) {\n  const staticData: Record<string, any> = {}\n  for (const path in pages) {\n    staticData[path] = pages[path].staticData\n  }\n  return staticData\n}\n\nif ((globalThis as any)['__vite_pages_use_static_data']) {\n  throw new Error(\n    `[vite-pages] global hooks (.e.g useStaticData) already exists on window. It means there are multiple vite-pages runtime in this page. Please report this to vite-pages.`\n  )\n} else {\n  // make them available in vite-plugin-react-pages/client\n  ;(globalThis as any)['__vite_pages_use_static_data'] = useStaticData\n  ;(globalThis as any)['__vite_pages_use_all_pages_outlines'] =\n    useAllPagesOutlines\n}\n","import { useLayoutEffect, useEffect } from 'react'\n\nexport const isSSR = import.meta.env.SSR\n\n// fix warning of useLayoutEffect during ssr\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect\n","import { useState, useContext, useRef } from 'react'\nimport { unstable_batchedUpdates as batchedUpdates } from 'react-dom'\nimport type { LoadState } from '../../clientTypes'\nimport { dataCacheCtx, setDataCacheCtx } from './ctx'\nimport { usePageModule } from './state'\nimport { useIsomorphicLayoutEffect } from './utils'\n\nexport default function useAppState(routePath: string) {\n  const dataCache = useContext(dataCacheCtx)\n  const setDataCache = useContext(setDataCacheCtx)\n\n  const [loadState, setLoadState] = useState<LoadState>(() => {\n    if (dataCache[routePath]) {\n      // this is a ssr or hydration\n      // this page's data has already been loaded\n      return {\n        type: 'loaded',\n        routePath,\n      }\n    }\n    if (routePath === '/internal-404-page') {\n      // this is a ssr or hydration\n      // for the 404 page\n      return {\n        type: '404',\n        routePath,\n      }\n    }\n    return {\n      type: 'loading',\n      routePath,\n    }\n  })\n\n  const onLoadState = (\n    type: LoadState['type'],\n    routePath: string,\n    error?: any\n  ) => setLoadState({ type, routePath, error })\n\n  const loading = usePageModule(routePath)\n  const loadingRef = useRef<Promise<any> | undefined>()\n  useIsomorphicLayoutEffect(() => {\n    loadingRef.current = loading\n    if (!loading) {\n      onLoadState('404', routePath)\n    } else {\n      if (dataCache[routePath]) {\n        /**\n         * Data already exists. Possible causes:\n         * - User navigates back to a loaded page.\n         * - This is a hmr update during dev. The dataCache[routePath] contains the old data. We need to load() the new data (but don't show loading state).\n         * - This is a ssr client-side render. The page data is loaded before hydration.\n         */\n        onLoadState('loaded', routePath)\n        if (import.meta.hot) {\n          // If user navigates back to a loaded page during dev\n          // this will also be executed.\n          // But in this case, it will import() the same es module again,\n          // which is handled by the browser es module cache.\n          // So it won't load the module from dev server again and won't evaluate the module again.\n          load()\n        }\n      } else {\n        onLoadState('loading', routePath)\n        load()\n      }\n    }\n\n    function load() {\n      loading!.then(\n        (page) =>\n          loading === loadingRef.current &&\n          batchedUpdates(() => {\n            onLoadState('loaded', routePath)\n            setDataCache((prev) => ({\n              ...prev,\n              [routePath]: page.default,\n            }))\n          }),\n        (error) =>\n          loading === loadingRef.current &&\n          onLoadState('load-error', routePath, error)\n      )\n    }\n  }, [loading])\n\n  return loadState\n}\n","import React, { useContext } from 'react'\nimport { dataCacheCtx } from './ctx'\nimport { useTheme } from './state'\nimport useAppState from './useAppState'\n\ninterface Props {\n  routePath: string\n}\n\nconst PageLoader = React.memo(({ routePath }: Props) => {\n  const Theme = useTheme()\n  const loadState = useAppState(routePath)\n  const dataCache = useContext(dataCacheCtx)\n\n  return <Theme loadState={loadState} loadedData={dataCache} />\n})\n\nexport default PageLoader\n","import React from 'react'\nimport {\n  useRoutes,\n  useLocation,\n  type Location,\n  type RouteObject,\n} from 'react-router-dom'\nimport { usePagePaths } from './state'\nimport PageLoader from './PageLoader'\n\nconst App = () => {\n  const pageRoutes = usePagePaths()\n    .filter((path) => path !== '/404')\n    .map((path) => {\n      return { path, element: <PageLoader routePath={path} /> } as RouteObject\n    })\n\n  pageRoutes.push({\n    path: '*',\n    element: (\n      <UseLocation>\n        {(location) => <PageLoader routePath={location.pathname} />}\n      </UseLocation>\n    ),\n  })\n\n  const routesRender = useRoutes(pageRoutes)\n\n  return routesRender\n}\n\nexport default App\n\nfunction UseLocation({ children }: { children: (location: Location) => any }) {\n  const location = useLocation()\n  // console.log('###UseLocation', location)\n  return children(location)\n}\n"],"names":["dataCacheCtx","createContext","setDataCacheCtx","Error","atom","useAtomValue","Jotai.useAtomValue","Jotai.useSetAtom","useTheme","usePagePaths","usePageModule","useStaticData","useAllPagesOutlines","initialPagePaths","Object","keys","initialPages","import","meta","hot","setTheme","accept","module","console","error","Theme","default","themeAtom","initialTheme","set","useAtom","setPages","setAllPagesOutlines","pagesAtom","pagePathsAtom","sort","staticDataAtom","toStaticData","allPagesOutlinesAtom","setPagesAtom","get","newPages","newStaticData","pages","path","newPage","page","dequal","staticData","undefined","fromEntries","entries","filter","k","v","newPagePaths","dataAtoms","atomFamily","staticDataAtoms","useUpdateAtom","pagePath","data","useMemo","selector","selection","timeout","useEffect","setTimeout","then","mod","useState","globalThis","isSSR","env","SSR","useIsomorphicLayoutEffect","useLayoutEffect","useAppState","routePath","dataCache","useContext","setDataCache","loadState","setLoadState","type","onLoadState","loading","loadingRef","useRef","current","load","batchedUpdates","prev","PageLoader","React","memo","_jsx","loadedData","App","pageRoutes","map","element","push","UseLocation","children","location","pathname","routesRender","useRoutes","useLocation"],"mappings":"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","x_google_ignoreList":[1,2,3]}
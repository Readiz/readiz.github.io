import{p as m}from"./AHC-27_-420af38d.js";import{u as i,j as e,a as n,F as t}from"./ssg-client-993c848d.js";import{C as h}from"./Comment-31c59be6.js";import{H as r}from"./Header-a1c9ae24.js";import{T as d}from"./TagList-4742d679.js";import"./katex.min-4ed993c7.js";import"./index.module-caf545e8.js";function l(s){const a=Object.assign({p:"p",h1:"h1",span:"span",math:"math",semantics:"semantics",mrow:"mrow",mn:"mn",mo:"mo",annotation:"annotation",mi:"mi",code:"code"},i(),s.components);return n(t,{children:[e(r,{}),`
`,e(a.p,{children:"이 글은 AHC 27의 풀이 방법에 대해 내 접근을 정리한 글이다."}),`
`,e(a.h1,{id:"문제-분석",children:"문제 분석"}),`
`,n(a.p,{children:[e(a.span,{className:"math math-inline",children:n(a.span,{className:"katex",children:[e(a.span,{className:"katex-mathml",children:e(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:n(a.semantics,{children:[n(a.mrow,{children:[e(a.mn,{children:"20"}),e(a.mo,{children:"×"}),e(a.mn,{children:"20"})]}),e(a.annotation,{encoding:"application/x-tex",children:"20 \\times 20"})]})})}),n(a.span,{className:"katex-html","aria-hidden":"true",children:[n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),e(a.span,{className:"mord",children:"20"}),e(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),e(a.span,{className:"mbin",children:"×"}),e(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.6444em"}}),e(a.span,{className:"mord",children:"20"})]})]})]})})," 크기부터 ",e(a.span,{className:"math math-inline",children:n(a.span,{className:"katex",children:[e(a.span,{className:"katex-mathml",children:e(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:n(a.semantics,{children:[n(a.mrow,{children:[e(a.mn,{children:"40"}),e(a.mo,{children:"×"}),e(a.mn,{children:"40"})]}),e(a.annotation,{encoding:"application/x-tex",children:"40 \\times 40"})]})})}),n(a.span,{className:"katex-html","aria-hidden":"true",children:[n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),e(a.span,{className:"mord",children:"40"}),e(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),e(a.span,{className:"mbin",children:"×"}),e(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.6444em"}}),e(a.span,{className:"mord",children:"40"})]})]})]})})," 크기를 가지는 2차원 맵이 있고, 이 맵 위를 로봇 청소기가 지나간다. 원점에서 출발해서 원점으로 돌아오는 경로를 하나 리턴해야하고, 이 경로는 기본적으로 짧을 수록 좋다. 그렇지만, 각 구역마다 장애물이 존재하며, 구역마다 쓰레기가 쌓이는 속도가 다르기 때문에, 경로를 잘 만들어야 한다."]}),`
`,e(a.h1,{id:"score-식-분석",children:"Score 식 분석"}),`
`,n(a.p,{children:["일단 길이 ",e(a.span,{className:"math math-inline",children:n(a.span,{className:"katex",children:[e(a.span,{className:"katex-mathml",children:e(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:n(a.semantics,{children:[e(a.mrow,{children:e(a.mi,{children:"L"})}),e(a.annotation,{encoding:"application/x-tex",children:"L"})]})})}),e(a.span,{className:"katex-html","aria-hidden":"true",children:n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.6833em"}}),e(a.span,{className:"mord mathnormal",children:"L"})]})})]})}),"의 ",e(a.code,{children:"path"}),"를 만들었다고 치면, 한번 로봇을 순회시킨다. 그러고나서, ",e(a.span,{className:"math math-inline",children:n(a.span,{className:"katex",children:[e(a.span,{className:"katex-mathml",children:e(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:n(a.semantics,{children:[e(a.mrow,{children:e(a.mi,{children:"L"})}),e(a.annotation,{encoding:"application/x-tex",children:"L"})]})})}),e(a.span,{className:"katex-html","aria-hidden":"true",children:n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.6833em"}}),e(a.span,{className:"mord mathnormal",children:"L"})]})})]})})," ~ ",e(a.span,{className:"math math-inline",children:n(a.span,{className:"katex",children:[e(a.span,{className:"katex-mathml",children:e(a.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:n(a.semantics,{children:[n(a.mrow,{children:[e(a.mn,{children:"2"}),e(a.mi,{children:"L"}),e(a.mo,{children:"−"}),e(a.mn,{children:"1"})]}),e(a.annotation,{encoding:"application/x-tex",children:"2L - 1"})]})})}),n(a.span,{className:"katex-html","aria-hidden":"true",children:[n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.7667em",verticalAlign:"-0.0833em"}}),e(a.span,{className:"mord",children:"2"}),e(a.span,{className:"mord mathnormal",children:"L"}),e(a.span,{className:"mspace",style:{marginRight:"0.2222em"}}),e(a.span,{className:"mbin",children:"−"}),e(a.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),n(a.span,{className:"base",children:[e(a.span,{className:"strut",style:{height:"0.6444em"}}),e(a.span,{className:"mord",children:"1"})]})]})]})})," 구간 경로 방문을 시키면서, 전체 맵의 더러움 정도를 합한 것이 스코어가 된다."]}),`
`,e(a.h1,{id:"초반-전략",children:"초반 전략"}),`
`,n(a.p,{children:[e(a.code,{children:"dfs"})," 알고리즘을 통해 깊이 우선으로 탐색시켜, 최대한 방문한 곳은 1번만 방문하는 식으로 해서 다시 원점으로 복귀하도록 했다."]}),`
`,e(a.h1,{id:"중반-전략",children:"중반 전략"}),`
`,n(a.p,{children:[e(a.code,{children:"dfs"})," 도 여러 방법으로 방문이 가능함에 착안, ",e(a.code,{children:"score"}),"를 계산할 수 있도록 로직을 짰고, 여러 ",e(a.code,{children:"dfs"})," 경로 중 ",e(a.code,{children:"score"}),"가 최소가 되는 경로를 리턴하도록 했다."]}),`
`,e(a.h1,{id:"후반-전략",children:"후반 전략"}),`
`,e(a.p,{children:"딱히 후반 전략을 떠올리지 못했다. 영역을 나눠야 한다.. 까지는 생각했지만, 영역을 나누고 어떻게 방문하지? 에서 구현을 실제로 이루어내지는 못했음."}),`
`,e(a.p,{children:"다른 후기글을 읽어보니 빔 탐색 등을 활용해서, 역시 쉽게 더러워지는 곳을 여러번 방문하도록 경로를 짜는 방법이 주효. 만약 이렇게 탐색했는데 미방문 지역이 있다면, 끝에 미방문 지역을 붙이는 것이 아니라 기존 경로를 최대한 수정하는 방식으로 미방문 지역을 방문하도록 조작하는듯 하다."}),`
`,e(d,{}),`
`,e(h,{})]})}function o(s={}){const{wrapper:a}=Object.assign({},i(),s.components);return a?e(a,Object.assign({},s,{children:e(l,s)})):l(s)}const p=Object.freeze(Object.defineProperty({__proto__:null,default:o},Symbol.toStringTag,{value:"Module"})),c={};c.outlineInfo=m;c.main=p;export{c as default};

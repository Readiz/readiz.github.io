import{p as r}from"./HilbertCurve_-f79f10a5.js";import{u as l,j as n,a,F as c}from"./ssg-client-4d0d4f51.js";import{I as h}from"./Image-5e892e16.js";import{C as m}from"./Comment-40ea10ce.js";import"./index.module-caf545e8.js";import{H as d}from"./Header-cd8dda2e.js";import"./katex.min-4ed993c7.js";function i(t){const e=Object.assign({h2:"h2",ul:"ul",li:"li",a:"a",p:"p",code:"code",span:"span",math:"math",semantics:"semantics",mrow:"mrow",mi:"mi",annotation:"annotation",mo:"mo",pre:"pre",h3:"h3",h4:"h4",mn:"mn"},l(),t.components);return a(c,{children:[n(d,{}),`
`,n(e.h2,{id:"hilbert-curve",children:"Hilbert Curve"}),`
`,a(e.ul,{children:[`
`,a(e.li,{children:["Wikipedia: ",n(e.a,{href:"https://en.wikipedia.org/wiki/Hilbert_curve",children:"https://en.wikipedia.org/wiki/Hilbert_curve"})]}),`
`,a(e.li,{children:["Codeforces blog: ",n(e.a,{href:"https://codeforces.com/blog/entry/61203",children:"https://codeforces.com/blog/entry/61203"})]}),`
`,a(e.li,{children:["Hilbert MO 소개: ",n(e.a,{href:"https://tamref.com/97",children:"https://tamref.com/97"})]}),`
`]}),`
`,a(e.p,{children:[n(e.code,{children:"Hilbert Curve"}),"는 정수좌표계에서 사용가능한 일종의 ",n(e.code,{children:"Space-Filling Curve"})," 이다. 1차원 좌표계에서 어떤 좌표 리스트가 있어서 그들을 최단 경로로 방문해야 한다고 한다면 이를 구하는 것은 간단하다. 위치를 정렬해서 오름차순이나 내림차순으로 방문하면 된다. 2차원 좌표계가 되면 이야기가 많이 복잡해진다. 이를 ",n(e.code,{children:"Hilbert Curve"})," 를 사용해서 1차원 좌표계처럼 2차원 좌표계를 ",n(e.code,{children:"projection"})," 할 수 있고, 휴리스틱하게 어느정도 가까운 점들끼리 방문할 수 있게 된다."]}),`
`,n(h,{src:"hilbertcurve.png"}),`
`,a(e.p,{children:["아래 코드는 서두의 codeforces blog에서 공유된 코드로, 임의의 ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[n(e.mrow,{children:n(e.mi,{children:"x"})}),n(e.annotation,{encoding:"application/x-tex",children:"x"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"0.4306em"}}),n(e.span,{className:"mord mathnormal",children:"x"})]})})]})}),", ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[n(e.mrow,{children:n(e.mi,{children:"y"})}),n(e.annotation,{encoding:"application/x-tex",children:"y"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"})]})})]})})," 좌표가 주어졌을 때의 Hilbert Curve 상의 순서를 ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[a(e.mrow,{children:[n(e.mi,{children:"O"}),n(e.mo,{stretchy:"false",children:"("}),n(e.mi,{children:"log"}),n(e.mo,{children:"⁡"}),n(e.mi,{children:"N"}),n(e.mo,{stretchy:"false",children:")"})]}),n(e.annotation,{encoding:"application/x-tex",children:"O(\\log N)"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),n(e.span,{className:"mopen",children:"("}),a(e.span,{className:"mop",children:["lo",n(e.span,{style:{marginRight:"0.01389em"},children:"g"})]}),n(e.span,{className:"mspace",style:{marginRight:"0.1667em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),n(e.span,{className:"mclose",children:")"})]})})]})})," 시간 복잡도로 구할 수 있다."]}),`
`,n(e.pre,{children:n(e.code,{className:"language-cpp",children:`constexpr int rotateDelta[4] = {3, 0, 0, 1};
inline int64_t hilbertOrder(int x, int y, int pow, int rotate) {
	if (pow == 0) {
		return 0;
	}
	int hpow = 1 << (pow-1);
	int seg = (x < hpow) ? (
		(y < hpow) ? 0 : 3
	) : (
		(y < hpow) ? 1 : 2
	);
	seg = (seg + rotate) & 3;
	int nx = x & (x ^ hpow), ny = y & (y ^ hpow);
	int nrot = (rotate + rotateDelta[seg]) & 3;
	int64_t subSquareSize = int64_t(1) << (2*pow - 2);
	int64_t ans = seg * subSquareSize;
	int64_t add = hilbertOrder(nx, ny, pow-1, nrot);
	ans += (seg == 1 || seg == 2) ? add : (subSquareSize - add - 1);
	return ans;
}
`})}),`
`,n(e.h3,{id:"활용",children:"활용"}),`
`,n(e.h4,{id:"mos-알고리즘의-정렬-순서로-활용하기",children:"Mo's 알고리즘의 정렬 순서로 활용하기"}),`
`,a(e.p,{children:[n(e.code,{children:"Mo's"})," 알고리즘의 경우 쿼리 문제에서 쿼리의 ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[n(e.mrow,{children:n(e.mi,{children:"l"})}),n(e.annotation,{encoding:"application/x-tex",children:"l"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"0.6944em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.01968em"},children:"l"})]})})]})}),", ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[n(e.mrow,{children:n(e.mi,{children:"r"})}),n(e.annotation,{encoding:"application/x-tex",children:"r"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"0.4306em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"r"})]})})]})})," 기준으로 정렬해서 동작하는 알고리즘이다. 이에 관해서는 글 서두에 있는 블로그에 잘 정리되어 있다. ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[n(e.mrow,{children:n(e.mi,{children:"N"})}),n(e.annotation,{encoding:"application/x-tex",children:"N"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"0.6833em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]})}),"과 ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[n(e.mrow,{children:n(e.mi,{children:"Q"})}),n(e.annotation,{encoding:"application/x-tex",children:"Q"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),n(e.span,{className:"mord mathnormal",children:"Q"})]})})]})}),"가 거의 유사한 문제에서는 ",n(e.code,{children:"Mo's"})," 알고리즘에 ",n(e.code,{children:"zigzag"})," 아이디어를 섞은 것과 ",n(e.code,{children:"Hilbert Curve"}),"를 활용한 방식이 거의 유사한 성능을 보인다. ",n(e.code,{children:"수열과 쿼리 0"})," 문제에서 측정한 속도는 아래와 같다."]}),`
`,a(e.ul,{children:[`
`,a(e.li,{children:["일반 ",n(e.code,{children:"Mo's"}),": 1070 ms"]}),`
`,a(e.li,{children:[n(e.code,{children:"Mo's"})," + ",n(e.code,{children:"zigzag"}),": 680 ms"]}),`
`,a(e.li,{children:[n(e.code,{children:"Mo's"})," + ",n(e.code,{children:"Hilbert"}),": 660 ms"]}),`
`]}),`
`,n(e.h4,{id:"heuristics-문제에-활용하기",children:"Heuristics 문제에 활용하기"}),`
`,a(e.p,{children:["성능을 요하는 ",n(e.code,{children:"TSP"})," 문제에서 활용 가능하다. 임의의 좌표를 비용을 최소로 해서 방문해야 할때, 위에서 살펴본 것처럼 2차원 좌표계를 1차원 좌표계인 것처럼 순서를 정해서 방문할 수 있다. 대충 ",n(e.code,{children:"int map[1000][1000]"})," 정도까지는 미리 순서를 저장해두고 ",n(e.span,{className:"math math-inline",children:a(e.span,{className:"katex",children:[n(e.span,{className:"katex-mathml",children:n(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:a(e.semantics,{children:[a(e.mrow,{children:[n(e.mi,{children:"O"}),n(e.mo,{stretchy:"false",children:"("}),n(e.mn,{children:"1"}),n(e.mo,{stretchy:"false",children:")"})]}),n(e.annotation,{encoding:"application/x-tex",children:"O(1)"})]})})}),n(e.span,{className:"katex-html","aria-hidden":"true",children:a(e.span,{className:"base",children:[n(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),n(e.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"O"}),n(e.span,{className:"mopen",children:"("}),n(e.span,{className:"mord",children:"1"}),n(e.span,{className:"mclose",children:")"})]})})]})}),"에 구하는 것이 좋은 방식으로 보인다. 이전에 다뤘던 ",n(e.code,{children:"Angle Sort"}),"와의 성능 비교도 이후에 진행해봐야겠다."]}),`
`,n(e.pre,{children:n(e.code,{className:"language-cpp",children:`// [TODO] 2차원 공간에 Hilbert Curve 방문 순서를 채우는 코드
`})}),`
`,n(m,{})]})}function o(t={}){const{wrapper:e}=Object.assign({},l(),t.components);return e?n(e,Object.assign({},t,{children:n(i,t)})):i(t)}const p=Object.freeze(Object.defineProperty({__proto__:null,default:o},Symbol.toStringTag,{value:"Module"})),s={};s.outlineInfo=r;s.main=p;export{s as default};

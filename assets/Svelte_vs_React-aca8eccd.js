import{p as r}from"./Svelte_vs_React_-cde38ef6.js";import{u as l,j as c,a as n,F as i}from"./ssg-client-23afceb3.js";import{C as h}from"./Comment-68afda01.js";import{H as a}from"./Header-6c86a0c6.js";import{T as s}from"./TagList-824f7517.js";import"./index.module-caf545e8.js";function t(d){const e=Object.assign({h2:"h2",p:"p",code:"code",em:"em"},l(),d.components);return n(i,{children:[c(a,{}),`
`,c(e.h2,{id:"svelte가-뭔데",children:"Svelte가 뭔데?"}),`
`,n(e.p,{children:[c(e.code,{children:"Svelte"}),"는 ",c(e.code,{children:"HTML"})," 작성구조와 거의 유사한 형태로 컴포넌트를 생성할 수 있는 ",c(e.code,{children:"React"}),"와 유사한 ",c(e.code,{children:"FE Framework"}),"(프레임워크가 맞는지에 대한 논쟁은 일단 넘어가자)이다. 가장 큰 특징은 ",c(e.code,{children:"React"})," 처럼 ",c(e.code,{children:"state"}),"와 ",c(e.code,{children:"props"})," 사용이 인위적이지 않고, 직관적이며 컴포넌트 랜더링 업데이트가 자동적으로 된다는 것이다. (가령 ",c(e.code,{children:"useState"}),"를 쓰지 않더라도)"]}),`
`,n(e.p,{children:["개인적으로 ",c(e.code,{children:"Svelte"})," 를 참 좋아한다. 직관적이며, ",c(e.code,{children:"JSX"}),"라는 희대의 비표준(내가 생각하기에 그렇다)을 쓰지 않을 수 있기에 그렇다."]}),`
`,n(e.p,{children:[c(e.code,{children:"Svelte"})," 자체가 참 잘 만들어진 언어이고 사용에도 불편함이 전혀 없고, 실제 나의 Toy Project에도 다수 활용했다. 다만, 치명적인 문제가 있는데 바로 생태계이다. 생태계가 갖추어지지 않은 상태에서는 아무리 좋아도 의미가 없다. 2023년이다. ",c(e.code,{children:"Component"})," 기반 개발이 일상화 되어 있고, 모든 것을 혼자 만들 수 없는 세상이다. 이 점이 나는 너무 아쉽다."]}),`
`,n(e.p,{children:["만약 ",c(e.code,{children:"Svelte"}),"가 ",c(e.code,{children:"React"}),"가 나온 한참 이후 나오지 않고 한 1~2년 격차를 두었을 때 나왔었다면 ",c(e.code,{children:"vue"})," 처럼 2인자 역할을 할 수도 있었을 것이다. 물론 요즘은 유명한 프로젝트들은 ",c(e.code,{children:"Svelte"}),"도 병렬로 지원하는 경우들이 많이 보이지만, 99개가 ",c(e.code,{children:"Svelte"}),"를 지원한다 하더라도 결국 1개가 지원하지 않는다면, 매우 귀찮음이 따르게 된다."]}),`
`,c(e.h2,{id:"고질적인-문제인-부족한-컴포넌트의-해결책",children:"고질적인 문제인 부족한 컴포넌트의 해결책?"}),`
`,n(e.p,{children:["없다. 이게 문제다. 다른 사소한 문제점들이야 어떻게든 고쳐나가거나 하면 되는 문제인데, 이건 해결책이 아예 ",c(e.em,{children:"없는"})," 수준이다. 꾸준히 개발이 되어야 하는데, 이미 기업들 입장에서도 ",c(e.code,{children:"React"})," 와 같은 것들을 잘 사용하고 있는 입장에서 새로운 컴포넌트들을 다른 언어로 또 개발하게 할 유인책이 없다. 물론 ",c(e.code,{children:"React"})," 컴포넌트들을 ",c(e.code,{children:"Svelte"}),"에서도 사용하게 하는 방식을 취하는 방식의 해결책이 있을 수 있다. 근데 그럼 ",c(e.code,{children:"React"})," 쓰면 되지 왜 ",c(e.code,{children:"Svelte"})," 쓰겠는가."]}),`
`,c(e.h2,{id:"sveltekit",children:"Sveltekit?"}),`
`,n(e.p,{children:["나는 이게 정말 별로라고 생각한다. ",c(e.code,{children:"Svelte"}),"의 핵심은 간단함에 있었다. 그런데 이 프로젝트는 너무 복잡하다. 실제로 ",c(e.code,{children:"Svelte"})," 개발을 주도하던 개발자도 이 ",c(e.code,{children:"Sveltekit"}),"의 첫번째 정식버전을 내놓기까지 상당한 시간이 걸렸다. (실력있는 개발자임에도) 그리고 ",c(e.code,{children:"Svelte"})," 릴리즈 시점과 마찬가지로 이미 ",c(e.code,{children:"SSR"})," 생태계에 이미 강자들이 다수 존재한다. 이들 사이에 ",c(e.code,{children:"Svelte"}),"를 쓸 수 있다는 이유만으로 ",c(e.code,{children:"Sveltekit"}),"을 사용하게 하기에는 너무 메리트가 적다."]}),`
`,n(e.p,{children:["그래서 새 블로그를 만들 때는 내가 ",c(e.em,{children:"사랑하던"})," ",c(e.code,{children:"Svelte"}),"를 버리고 ",c(e.code,{children:"React"})," 기반의 ",c(e.code,{children:"vite"}),"를 사용하기로 마음먹었다. 2023년에서는 이게 제일 쓰기 쉽고, 생태계도 크니까. 몇년간 지켜보며 사용했던 프로젝트인 ",c(e.code,{children:"Svelte"}),"인데, 몇년째 이런 컴포넌트 부족 문제들이 해결되지 않아서 나는 더이상 쓰지 않을 것 같다."]}),`
`,c(e.p,{children:"그래도 정들었던 프로젝트여서 한때는 컴포넌트 만들어서 공개도 하고 했는데 이게 뭐 한두사람 더 달라붙는다고 해결된 문제는 아니라서.."}),`
`,c(s,{}),`
`,c(h,{})]})}function m(d={}){const{wrapper:e}=Object.assign({},l(),d.components);return e?c(e,Object.assign({},d,{children:c(t,d)})):t(d)}const p=Object.freeze(Object.defineProperty({__proto__:null,default:m},Symbol.toStringTag,{value:"Module"})),o={};o.outlineInfo=r;o.main=p;export{o as default};

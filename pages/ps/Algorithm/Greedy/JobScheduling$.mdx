---
title: Job Scheduling
writtendate: 2023-10-24
---
import Image from '@/components/Image'
import Comment from '@/components/Comment'
import TagList from '@/components/TagList'
import Header from '@/components/Header'
import 'katex/dist/katex.min.css'

<Header />

## Job Scheduling

이 유형은 문제에서 주어진 조건에 따라 풀이 방법이 매우 다양하게 나뉠 수 있다.


### 작업 배정을 할지 안할지만 결정

- 회의실 배정 문제: https://www.acmicpc.net/problem/1931
- 가젤 님의 관련 티스토리 글 (+ 아래 사진 출처): https://gazelle-and-cs.tistory.com/59
<Image src="meeting_assign.gif" />

```cpp
// Greedy 기초
// 작업을 진행하는데 걸리는 시간 T가 주어지지 않았다.
// 그 작업을 채택할지 안할지만 보면 된다.

// 1. 정렬 Phase
// 끝나는 시간 기준으로 정렬한다.
// 2. 할당 Phase
// 앞에서부터 차례대로 할당한다.
struct Meeting {
    int s, e;
};

int solve() {
    vector<Meeting> v;
    for(int i = 0; i < N; ++i) {
        int a, b; scanf("%d %d", &a, &b);
        v.push_back({a, b});
    }

    sort(v.begin(), v.end(), [&](Meeting& a, Meeting& b) -> bool {
        if (a.e != b.e) return a.e < b.e;
        return a.s < b.s;
    });
    
    int last = 0;
    int ans = 0;
    for(auto& item: v) {
        if (item.s >= last) ++ans, last = item.e;
    }
    printf("%d\n", ans);

    return 0;
}
```

### 작업 수행 시간이 T = 1인 경우

- ABC 325 Round D번: https://atcoder.jp/contests/abc325/tasks/abc325_d

```cpp
// 기본적으로 시간을 1부터 끝까지 훑으면서 할당하는 것
// 다만, 더 이상 후보군이 없을 때는 기록이 있는 지점부터 다시 시작
// -> 이렇게 안하면 구간 클 경우 TLE

// 과정을 다시 요약하면 아래와 같다. (time에 대한 sliding window 기법)
// 1. 가장 r_i가 작은 시간 작업부터 시작
// 1-1. r_i와 같은 시간에 시작하는 작업들은 모두 pq에 넣는다.
// 2. 그 중 d_i가 가장 짧은 녀석부터 시간을 1씩 증가시켜가면서 실제로 할당한다.
// 2-1. 할당할 때 한번에 다 하는게 아니라, 현재 시간에 1개만 할당하고, 다음 시간을 연속해서 보면서 할당한다.
// 3. 만약 보려는 녀석이 이미 보고있는 시간대를 지나갔다면 버린다.
map<ll, priority_queue<ll, vector<ll>, greater<>>> M;
void solve() {
    FOR(i,0,N) {
        ll a, b; scanf("%lld %lld", &a, &b);
        b += a;
        if (M.find(a) == M.end()) M[a] = {};
        M[a].push(b);
    }
    int ans = 0;
    // unit time: 1임
    ll ctime = 0;
    priority_queue<ll, vector<ll>, greater<>> gpq;

    auto it = M.begin();
    for(ll ctime = 1; ; ++ctime) { // 시간을 증가시켜가면서 본다.
        if (gpq.size() == 0) {
            // 아무것도 없으니 내맘대로 시간을 맞춘다~
            if (it == M.end()) break;
            auto& cur = *it;
            ctime = cur.first;
            ++it;
        }
        if (M.find(ctime) != M.end()) {
            it = M.find(ctime);
            auto& cur = *it;
            auto& pq = cur.second;
            while(pq.size()) gpq.push(pq.top()), pq.pop();
            ++it;
        }
        // 유효하지 않은 gpq 값을 꺼낸다.
        while (gpq.size() && gpq.top() < ctime) gpq.pop();
        // pq에서 가장 작은거 하나 꺼내서 쓴다.
        if (gpq.size()) {
            gpq.pop();
            ++ans;
        }
    }
    printf("%d\n", ans);
}
```

## 전부 할당해야할 때 필요한 기계의 수를 계산하는 유형

- 강의실 배정 문제: https://www.acmicpc.net/problem/11000

```cpp
struct Range {
    int l, r;
    bool operator<(const Range& t) {
        if (l != t.l) return l < t.l;
        return r < t.r;
    }
};

void solve(vector<Range>& v) {
    sort(v.begin(), v.end()); // 빨리 시작하는 순서대로 정렬

    priority_queue<int, vector<int>, greater<>> pq;
    for(auto& item: v) {
        if (pq.size() == 0) {
            pq.push(item.r);
            continue;
        }
        if (item.l >= pq.top()) { // 일단 들어갈 수 있다.
            pq.pop();
            pq.push(item.r); // 기존 녀석을 대체
        } else { // 못들어가는 case이다. (현재 가장 빨리 끝나는 녀석보다도 시작이 빠름)
            pq.push(item.r);
        }
    }

    printf("%ld\n", pq.size());
}
```

## Time Complexity

- 우선 순위 큐 베이스 알고리즘이기 때문에 모두 $O(N\log N)$


<Comment />

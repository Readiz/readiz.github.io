---
title: Binary Search
writtendate: 2023-05-25
tags:
    - binary search
    - lower bound
    - upper bound
---
import Comment from '@/components/Comment'
import TagList from '@/components/TagList'
import Header from '@/components/Header'

<Header />

Binary Search의 구현에 관한 정리. 주제 자체는 `solved.ac` 기준 실버 티어 정도일 수도 있겠지만, 제대로 쓰기까지 상당한 시간이 걸리는 주제이기도 하다. 또, 각종 알고리즘에서 뜬금없이 튀어나오는 1순위. `O(n)`을 `O(log n)`으로 줄여주는 강력한 무기.

# 서론

Binary Search는 항상 구현이 헷갈린다. 범위를 어디까지 해야하는지, `l`, `r` 설정은 어떻게 해야하는지 등등...

여기서 그런 부분들을 한번 정리하고 넘어가고자 한다.


## Binary Search의 STL 사용 구현

우선 표준이 되는 `STL`을 사용한 Binary Search 사용법을 확인해보자. 사용할 때 `vector`는 정렬이 되어 있어야 한다. `lower_bound`는 찾고자 하는 값보다 `크거나 같은` 값이 처음으로 나오는 시점을 반환한다.

```cpp
auto it = lower_bound(v.begin(), v.end(), tval);
```

`upper_bound`도 거의 동일하지만 `크거나 같은` 이 아닌 `큰` 이다. 사용법은 완전히 동일하다. (결과만 달라진다)

```cpp
auto it = upper_bound(v.begin(), v.end(), tval);
```

`Binary Search`의 의의는 원소를 찾을 때 전체 원소(`O(n)`)를 찾지 않아도 됨에 그 의의가 있다. 절반씩 찾을 원소가 줄어드므로 `Master Theorem`에 의해 시간복잡도가 `O(log n)`으로 줄어들게 된다.

## Binary Search의 직접구현

직접 구현시에 신경써야 할 포인트들이 많이 있다.

1. 경계값 문제
    - `s`, `e` 범위를 `[s, e]`로 할 것인가? `[s, e)`로 할 것인가?
2. mid 값 설정 문제
    - `(s+e)/2` 로 할 것인가, `(s+e+1)/2`로 할 것인가?
3. loop시 `l`, `r` 조정 문제
    - 가령 `r = mid`로 할 것인가, `r = mid - 1`로 할 것인가?
4. `lower_bound`와 `upper_bound`의 실 구현

하나씩 해치워보자.

### 경계값 문제

이것의 답은 의외로 간단하다. 만약 찾고자 하는 값이 범위에 있는 값을 초과하는 경우를 받아들일 수 있느냐 없느냐의 문제이기도 한데, STL의 구현 기준으로, 찾는 값이 없을 경우 `end()`에 해당하는 `iterator`를 리턴하게 되어 있다.

### mid 값 설정 문제

이 부분도 생각을 좀 해봐야할 문제 중 하나다. 아래처럼 나눠서 생각해보자.

1. [s, e] 구간의 경우
    - 원소가 4개라고 가정해보자.
    - [1, 4]의 절반을 나누려면, `mid는 `2.5`가 되어야 한다.
    - [1, 2] / [3, 4] 로 나뉘는 것이 바람직하므로, `mid = (s + e) / 2`가 좋다.
2. [s, e) 구간의 경우
    - 원소가 5개라고 가정해보자.
    - 절반을 나누려면, [1,6)이 된다. `mid`는 `3`이 됨이 자연스럽다.
    - 이 경우 [1, 3] / [4, 6)으로 나뉘는 것이 바람직하므로, `mid = (s + e) /2`가 좋다.

즉, mid 값은 위 조건에 따라 분기해서 사용하면 된다.

### loop시 l, r 조정 문제

오름차순으로 정렬된 `arr[]`에서, 원소를 찾으면 원소 index, 못찾으면 -1을 리턴하는 예시를 보자.

```cpp
// [s, e] 구간 사용
int binarySearch(int arr[], int s, int e, int tval) {
    int l = s, int r = e, mid;
    while (l <= r) {
        mid = (l + r) >> 1;
        if (tval == arr[mid]) return mid;
        else if (tval < arr[mid]) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return -1;
}
```

표로 하나 예시를 살펴보자.

| index | 0 | 1  |  2 |  3  |4  |5  |6  |7  |
|:-|:-:|:-:|:-:  |:-: |:-: |:-:|:-:|:-:|
| **value**  |5 | 8  |  10|  14 |17 | 20| 22| 25|

이 경우, `10`을 찾는다고 가정해보자.

1. 첫번째 loop에서의 각 param 값은 아래와 같다.
    - l: 0
    - r: 7
    - mid: 3
    - 결과: `arr[3] = 14 > 10` 이므로, `r` 이 `2`로 조정된다.
2. 두번째 loop는 아래와 같이 된다.
    - l: 0
    - r: 2
    - mid: 1
    - 결과: `arr[1] = 8 > 10` 이므로, `l`이 `2`로 조정된다.
3. 세번째 loop는 `l` == `r` == `2`이므로, 값을 찾고 종료된다.

즉, 오름차순 정렬된 배열 기준으로, 중앙을 봤을 때 그 값이 찾는 값보다 더 크면 타겟값은 좌측에 있을 것이라 생각할 수 있으므로 `r`이 조정되는 것이며, 반대의 경우 `l`이 조정된다고 할 수 있다.

### lower_bound와 upper_bound의 실 구현

이 경우 더 분기를 줄이는 방법도 있지만, 구현이 쉬운 방법으로 아래처럼 `binarySearch` 함수를 변경해볼 수 있다.

```cpp
// [s, e) 구간 사용
int lowerBound(int arr[], int s, int e, int tval) {
    int l = s, int r = e, mid, ans = e; // ans의 초기값에 유의
    while (l <= r) {
        mid = (l + r + 1) >> 1; // [s, e) 이므로...
        if (tval == arr[mid]) {
            ans = mid;
            r = mid - 1; // 만약 원소가 1 2 3 3 3 3 3 4 5 처럼 되어 있다면, 처음 찾은 3보다 더 왼쪽에 3이 또 있을 수 있다.
        }
        else if (tval < arr[mid]) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return ans;
}
```

`lower_bound`의 경우 위처럼만 수정하면 된다. 같을떄 `return` 하는 것이 아니라 더 찾는 것이 포인트.

`upper_bound`는 아래처럼 해볼 수 있다.


```cpp
// [s, e) 구간 사용
int upperBound(int arr[], int s, int e, int tval) {
    int l = s, int r = e, mid, ans = e; // ans의 초기값에 유의
    while (l <= r) {
        mid = (l + r + 1) >> 1; // [s, e) 이므로...
        if (tval == arr[mid]) {
            r = mid - 1;
        }
        else if (tval < arr[mid]) {
            ans = mid; // lowerBound 구현 대비 이것의 위치가 바뀐다.
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return ans;
}
```

`ans` 를 업데이트 하는 부분만 변경되기 때문에 쉽게 확인해볼 수 있다.

<TagList />
<Comment />

---
title: 시간복잡도
writtendate: 2023-06-01
tags:
    - time complexity
    - algorithm
---
import Comment from '@/components/Comment'
import TagList from '@/components/TagList'
import Header from '@/components/Header'
import TimeComplexity from './TimeComplexity'

<Header />

시간 복잡도 관련 정리

## 주요 시간 복잡도

<TimeComplexity />

## 시간 복잡도와 실제 수행 시간

위에서 이야기하는 `O(n)` / `O(log n)` 따위의 이야기는 많이 들었지만, 그래서 실제로 어떻게 쓰는지에 대한 이야기는 많이 부딪혀보지 않으면 느끼기 어렵다. 내가 느낀대로 정리해본다. 당연히 절대적인 것은 아니다.

### 컴퓨터의 초당 연산 처리 능력

사람보다 말이 많은데, 대충 일반적인 사용자 PC 기준 초당 `1억` ~ `10억` 개의 연산 정도를 처리 가능하단 것이 중론이다. 물론 이것을 너무 믿으면 안되는게, `CPU`가 `prefetching`도 하고, `branch prediction`도 하고, `pipelining`도 하기 때문에, 모든 요소를 알기란 어렵다. 정확한 수행시간이란 무조건 *부딪혀봐야* 아는 것이고, 보수적으로 `1억`을 기준점으로 잡아 풀고, 만약 이를 아슬아슬하게 넘어갈 것이 예상된다면 상수최적화를 시도해보는 것이 좋을 것이다.

### N 값 기준 허용되는 시간복잡도

나는 `N`의 값에 따라 대략 아래와 같은 기준을 쓰고 있다.

- `N <= 100`: `O(N^3)`, 최적화된 `O(N^4)` 알고리즘을 돌릴 수 있다.
- `N <= 1,000`: `O(N^2)`, 주로 `DP`로 푸는 문제에서 많이 사용되는 범위이다.
- `N <= 10,000`: 여기부턴 대략 `O(N^2)도 `timeout` 나기 쉽다. `O(n log n)` 정도가 허용된다고 봐야한다.
- `N <= 100,000`: 십만 단위를 넘어가면 슬슬 빡세다. `O(N^2)`는 무조건 `timeout` 나기 시작하는 구간. `O(n log n)` 와 동등, 혹은 그 이상의 알고리즘을 사용해야 한다.
- `N <= 1,000,000`: 여기부터는 `O(n)`을 슬슬 써야하는 단위이다. `O(n log n)`도 슬슬 시간이 소요되는 것이 눈에 들어오기 시작한다.
- `N >= 1,000,000,000`: `O(log n)`이 강제된다.

## Master's Theorem

### 작성중

<TagList />
<Comment />
